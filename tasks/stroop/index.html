<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stroop Task (Minimal)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; display:flex; align-items:center; justify-content:center; min-height:100vh; }
    .container { max-width: 720px; text-align:center; }
    .stimulus { font-size: 64px; font-weight: 700; letter-spacing: 1px; margin: 40px 0; }
    .hidden { display:none; }
    button { font-size: 18px; padding: 10px 18px; cursor: pointer; }
    .instructions { text-align:left; line-height:1.5; }
    .footer { margin-top:32px; color:#666; font-size:14px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Stroop Task</h1>
    <div id="screen-intro" class="instructions">
      <p>Decide the <b>INK COLOR</b> of the word, ignoring the word meaning.</p>
      <p>Press keys: <b>R</b> for RED, <b>G</b> for GREEN, <b>B</b> for BLUE.</p>
      <p>Do this as quickly and accurately as you can.</p>
      <p>When you’re ready, click Start. There are 40 trials.</p>
      <button id="btn-start">Start</button>
    </div>

    <div id="screen-trial" class="hidden">
      <div id="stimulus" class="stimulus">READY</div>
      <div class="footer">Keys: R = red, G = green, B = blue</div>
    </div>

    <div id="screen-end" class="hidden">
      <h2>Done!</h2>
      <p id="summary"></p>
      <button id="btn-download">Download CSV</button>
      <p class="footer">You can upload this CSV to the Python analysis later.</p>
    </div>
  </div>

<script>
(() => {
  // ---------- configurable parameters ----------
  const N_TRIALS = 40;             // total trials
  const COLORS = ["RED","GREEN","BLUE"];
  const COLOR_TO_CSS = { RED:"#d60000", GREEN:"#008a00", BLUE:"#004cdb" };
  const KEYMAP = { "r":"RED", "g":"GREEN", "b":"BLUE" };
  const ITI_MS = 500;              // inter-trial interval
  const MIN_RT = 200;              // for later summary only
  const MAX_RT = 2000;

  // ---------- state ----------
  const pid = "P" + Math.random().toString(36).slice(2,8).toUpperCase();
  let timeline = [];
  let trialIndex = -1;
  let awaiting = false;
  let tStart = 0;
  const rows = []; // data rows

  // ---------- helpers ----------
  function shuffle(a){
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function makeTimeline(n){
    const trials = [];
    // half congruent, half incongruent
    for (let i=0;i<n;i++){
      const word = COLORS[i % COLORS.length];
      const ink = (i < n/2) ? word : COLORS[(i + 1) % COLORS.length]; // simple mismatch
      trials.push({word, ink, condition: (word===ink) ? "congruent" : "incongruent"});
    }
    return shuffle(trials);
  }

  function setVisible(id, visible){
    document.getElementById(id).classList.toggle("hidden", !visible);
  }

  function showTrial(){
    trialIndex++;
    if (trialIndex >= timeline.length){
      endTask();
      return;
    }
    const stim = timeline[trialIndex];
    const el = document.getElementById("stimulus");
    el.textContent = stim.word;
    el.style.color = COLOR_TO_CSS[stim.ink];
    setVisible("screen-intro", false);
    setVisible("screen-end", false);
    setVisible("screen-trial", true);
    awaiting = true;
    tStart = performance.now();
  }

  function endTask(){
    setVisible("screen-trial", false);
    setVisible("screen-end", true);

    // compute quick summary (correct trials, trimmed RT)
    const correct = rows.filter(r => r.accuracy===1);
    const trimmed = correct.filter(r => r.rt_ms>=MIN_RT && r.rt_ms<=MAX_RT);
    const mean = (arr, k) => arr.reduce((s,x)=>s+x[k],0)/Math.max(arr.length,1);

    const mCong = mean(trimmed.filter(r=>r.condition==="congruent"), "rt_ms");
    const mIncong = mean(trimmed.filter(r=>r.condition==="incongruent"), "rt_ms");
    const diff = (mIncong - mCong).toFixed(1);

    document.getElementById("summary").textContent =
      `You finished ${rows.length} trials. Mean RT (trimmed) incongruent – congruent = ${diff} ms.`;
  }

  function onKey(e){
    if (!awaiting) return;
    const key = e.key.toLowerCase();
    if (!(key in KEYMAP)) return;
    const rt = performance.now() - tStart;
    awaiting = false;

    const stim = timeline[trialIndex];
    const correctColor = stim.ink;
    const chosenColor = KEYMAP[key];
    const acc = (chosenColor === correctColor) ? 1 : 0;

    rows.push({
      participant_id: pid,
      trial_index: trialIndex,
      condition: stim.condition,
      stimulus_word: stim.word,
      ink_color: stim.ink,
      correct_key: Object.keys(KEYMAP).find(k => KEYMAP[k]===correctColor),
      key_pressed: key,
      accuracy: acc,
      rt_ms: Math.round(rt),
      timestamp_iso: new Date().toISOString()
    });

    // small ITI before next trial
    setTimeout(showTrial, ITI_MS);
  }

  function toCSV(data){
    const cols = Object.keys(data[0]);
    const lines = [cols.join(",")];
    data.forEach(row => {
      const vals = cols.map(c => String(row[c]).replaceAll('"','""'));
      lines.push(vals.join(","));
    });
    return lines.join("\n");
  }

  function download(filename, text){
    const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  // ---------- wire up UI ----------
  document.getElementById("btn-start").addEventListener("click", () => {
    timeline = makeTimeline(N_TRIALS);
    trialIndex = -1;
    rows.length = 0;
    showTrial();
  });
  window.addEventListener("keydown", onKey);
  document.getElementById("btn-download").addEventListener("click", () => {
    if (rows.length === 0) return;
    download(`stroop_${pid}.csv`, toCSV(rows));
  });
})();
</script>
</body>
</html>
